// import "../grammar/stm.stg"

Header() ::= <<
/*
  this file was auto-generated
*/
>>

IncludeGuardBegin(headerfileName) ::= <<
#ifndef <headerfileName>
#define <headerfileName>
>>

IncludeGuardEnd(headerfileName) ::= <<
#endif
>>

m(name) ::= "m_<name>"

usart_callback(usart) ::= <<
/* gets called by the interrupt handler for <usart.Name> */
void rpc_<usart.Name>_receive()
{
  uint16_t data;

  if (USART_GetITStatus(<usart.Name>, USART_IT_RXNE) != RESET)
  {
    /* receive from the <usart.Name> */
    data = rpc_<usart.Name>_receive_char();

    /* enqueue the data in usart send2rpi queue */
    pilot_comm_enqueue_usart(get_spi_data(target_t_from_module_slot_and_port(<usart.ModuleSlot>, <usart.ModulePort>), data));

    /* pull the DATA pin high to signal available data */
    GPIO_WriteBit(GPIO_Pin_BOARD, GPIO_Pin_DATA_M2R, Bit_SET);
  }
}

>>

senddata(module) ::= <<
>>


Render(model) ::= <<

<Header()>
#include "plc.h"
#include \<limits.h>
#include "stm32_conf.h"
#include "gpio_config.h"
#include "delay.h"
#include "it_callback.h"
#include "ia8.h"
#include "pilot_comm.h"
#include "usart.h"
#include "pwm.h"
#include "i8.h"
#include "o8.h"
#include "pilot_usart.h"
#include "gps.h"
#include "gsm.h"
#include "rtc.h"
#include "counter8.h"
#include "io16.h"
#include "onewire.h"
#include "eeprom.h"
#include "spi.h"
#include "test.h"
#include "fpga.h"
#include "aio20.h"
#include "main.h"

typedef struct {
    long int tv_sec;            /* Seconds.  */
    long int tv_nsec;           /* Nanoseconds.  */
} /* __attribute__((packed)) */ IEC_TIMESPEC;  /* packed is gcc specific! */

IEC_TIMESPEC __CURRENT_TIME;

unsigned long long __tick;

/* cycle time */
unsigned int cycle_current; // time for the full cycle
unsigned int cycle_current_comm; //time until comm done
unsigned int cycle_current_read; //time until read
unsigned int cycle_current_program; //time for program
unsigned int cycle_current_write; //time until write

unsigned int cycle_min;
unsigned int cycle_max;

// plc_state
int plc_state;

// hard fault handler in C,
// with stack frame location as input parameter
// called from HardFault_Handler in file xxx.s
void hard_fault_handler_c (unsigned int * hardfault_args)
{
unsigned int stacked_r0;
unsigned int stacked_r1;
unsigned int stacked_r2;
unsigned int stacked_r3;
unsigned int stacked_r12;
unsigned int stacked_lr;
unsigned int stacked_pc;
unsigned int stacked_psr;

stacked_r0 = ((unsigned long) hardfault_args[0]);
stacked_r1 = ((unsigned long) hardfault_args[1]);
stacked_r2 = ((unsigned long) hardfault_args[2]);
stacked_r3 = ((unsigned long) hardfault_args[3]);

stacked_r12 = ((unsigned long) hardfault_args[4]);
stacked_lr = ((unsigned long) hardfault_args[5]);
stacked_pc = ((unsigned long) hardfault_args[6]);
stacked_psr = ((unsigned long) hardfault_args[7]);

printf ("\n\n[Hard fault handler - all numbers in hex]\n");
printf ("R0 = %x\n", stacked_r0);
printf ("R1 = %x\n", stacked_r1);
printf ("R2 = %x\n", stacked_r2);
printf ("R3 = %x\n", stacked_r3);
printf ("R12 = %x\n", stacked_r12);
printf ("LR [R14] = %x  subroutine call return address\n", stacked_lr);
printf ("PC [R15] = %x  program counter\n", stacked_pc);
printf ("PSR = %x\n", stacked_psr);
printf ("BFAR = %x\n", (*((volatile unsigned long *)(0xE000ED38))));
printf ("CFSR = %x\n", (*((volatile unsigned long *)(0xE000ED28))));
printf ("HFSR = %x\n", (*((volatile unsigned long *)(0xE000ED2C))));
printf ("DFSR = %x\n", (*((volatile unsigned long *)(0xE000ED30))));
printf ("AFSR = %x\n", (*((volatile unsigned long *)(0xE000ED3C))));
printf ("SCB_SHCSR = %x\n", SCB->SHCSR);

while (1);
}
/* init systick interrupt */
static void rpc_systick_init()
{
int priority;

/* configure the systick timer interval: 1000 -> 1ms interval */
if (SysTick_Config(SystemCoreClock / 1000))
  while(1); /* capture error */

/* calculate the priority value */
priority = NVIC_EncodePriority(NVIC_PriorityGroup_0, 0, 2);

/* set the priority value of the systick interrupt */
NVIC_SetPriority(SysTick_IRQn, priority);
}

static void rpc_send_startup_message()
{
printf("Pilot firmware version: <model.CodeGen.Version>\r\n");
  printf("Build Date: <model.CodeGen.Date>\r\n");
  #ifdef DEBUG
  printf("DEBUG enabled\r\n");
  #endif
<if (model.IsTest)>
  printf("Test run: enabled\r\n");
<else>
  printf("Test run: disabled\r\n");
<endif>

  /* module usage */
  <model.Modules:{m|printf("m<m.Slot>: <m.Name>\r\n");};separator="\n">

  	printf("Last Reset reason: ");
	  // test the reset flags in order because the pin reset is always set. 
	if (RCC_GetFlagStatus(RCC_FLAG_PORRST)) {
		printf("POR/PDR reset\r\n");
	}
	else if (RCC_GetFlagStatus(RCC_FLAG_SFTRST)) {
		printf("Software reset\r\n");
	}
	else if (RCC_GetFlagStatus(RCC_FLAG_IWDGRST)) {
		printf("Independent watchdog reset\r\n");
	}
	else if (RCC_GetFlagStatus(RCC_FLAG_WWDGRST)) {
		printf("Window watchdog reset\r\n");
	}
	else if (RCC_GetFlagStatus(RCC_FLAG_LPWRRST)) {
		printf("Low-power reset\r\n");
	}
	else if (RCC_GetFlagStatus(RCC_FLAG_PINRST)) {
		printf("PIN reset\r\n");
	}
	else {
		printf("unknown");
	}
}

static void pilot_send_eeprom_uids()
{
  int i; bool presence;
  pilot_eeprom_uid_t uid;
  pilot_eeprom_hid_t hid;

  printf("Module uids:\r\n");
  for (i = 0; i \< MODULES_COUNT; i++)
  {
    /* get the uid */
    presence = pilot_eeprom_get_module_uid((module_slot_t)i, &uid);

    /* get the hid */
    pilot_eeprom_get_module_hid((module_slot_t)i, &hid);

    /* module X: OK*/
    printf("module ");
    _putchar(i + 0x31);
    printf(": ");
    printf(presence ? "OK" : "  ");
    printf(" '");
    _putchars((char*)hid.data, EEPROM_HID_LENGTH);
    printf("'\r\n");
  }
}

volatile int module_inputs_changed = -1;
static void rpc_handle_module_inputs_changed()
{
  int slot;

  if (module_inputs_changed > -1)
  {
    slot = module_inputs_changed;

    /* mark the cmd as handled */
    module_inputs_changed = -1;

    switch (slot)
    {
<model.IO16s:{io16|
      case <io16.Slot>:
        rpc_<io16.Name>_set_irq_handled();
        break;
};separator="\n">
    }

    /* send the input changed cmd */
    pilot_comm_send_input_changed((module_slot_t)slot);
  }
}

void initialize_tick()
{
  __tick = 0ULL;

  /* cycle time */
  cycle_current = 0; // time for the full cycle
  cycle_current_comm = 0; //time until comm done
  cycle_current_read = 0; //time until read
  cycle_current_program = 0; //time for program
  cycle_current_write = 0; //time until write

  cycle_min = UINT_MAX;
  cycle_max = 0;

  // plc_state
  plc_state = 1;
}

static void pilot_main_loop()
{ 
  while(1)
  {
    DWT_CycCounterClear();

    pilot_handle_received_data();
    rpc_handle_module_inputs_changed();

    //communication time
    cycle_current_comm = DWT_CycCounterRead();

    //if plc is enabled, run plc code
    if (plc_state == 1)
    {
      //read inputs
      plc_read_inputs();
      cycle_current_read = DWT_CycCounterRead();

      //run code
      plc_run(__tick);
      cycle_current_program = DWT_CycCounterRead();

      //write outputs
      plc_write_outputs();
      cycle_current_write = DWT_CycCounterRead();

      //handle subscriptions
      pilot_comm_send_subscribed_plc_variable(plc_find_next_updated_variable());
    }

    //update cycle time
    cycle_current = DWT_CycCounterRead();
    if (cycle_min > cycle_current) cycle_min = cycle_current;
    if (cycle_max \< cycle_current) cycle_max = cycle_current;
  }
}

int main(void)
{
  /* initialize tick variables */
  initialize_tick();

  /* make sure SystemCoreClock is updated */
  SystemCoreClockUpdate();

  DWT_Enable(); //activate DWT-unit
  DWT_CycCounterEn(); // enable CPU cycle counter

  /* enable the systick interrupt */
  rpc_systick_init();

  /* initializes USART1 for debug messages */
  pilot_usart_init();

  /* initializes raspberry pi spi communication */
  pilot_comm_init();

  /* send a message over rs232 to rpi's /dev/ttyAMA0 */
  rpc_send_startup_message();

  /* initialize communication with the eeproms */
  pilot_eeprom_init();

  /* output the module uids */
  pilot_send_eeprom_uids();

  /* enable the rtc */
  rtc_init();

<if(model.SPIs)>
  /* initialize spi */
  pilot_spi_setup();
<endif>

<if(model.Usarts)>
  /* initialize usarts */
  <model.Usarts:{usart|rpc_<usart.Name>_init();};separator="\n">
<endif>
  
<if(model.Pwms)>
  /* initialize pwms */
  <model.Pwms:{pwm|<pwm.Name>_init();};separator="\n">
<endif>

<if(model.I8s)>
  /* initialize the i8s */
  <model.I8s:{i8|<i8.Name>_init();};separator="\n">
<endif>

<if (model.O8s)>
  /* initialize the o8s */
  <model.O8s:{o8|pilot_<o8.Name>_init();};separator="\n">
<endif>

<if(model.Counter8s)>
  /* initialize the counters */
  <model.Counter8s:{counter|pilot_<counter.Name>_init();};separator="\n">
<endif>

<if(model.GPSs)>
  /* initialize the gps */
  <model.GPSs:{gps|rpc_<gps.Name>_init();};separator="\n">
<endif>

<if(model.LORAs)>
  /* initialize the lora */
  <model.LORAs:{lora|rpc_<lora.Name>_init();};separator="\n">
<endif>

<if (model.GSMs)>
  /* initialize the gsm */
  <model.GSMs:{gsm|pilot_<gsm.Name>_init();};separator="\n">
<endif>

<if(model.IO16s)>
  /* initialize the io16 */
  <model.IO16s:{io16|rpc_<io16.Name>_init();};separator="\n">
<endif>

<if(model.OneWires)>
  /* intialize the one wire */
  <model.OneWires:{ow|rpc_<ow.Name>_init();};separator="\n">
<endif>

<if(model.SLCDs)>
  /* initialize the sharp lcd driver */
  <model.SLCDs:{slcd|pilot_<slcd.Name>_init();};separator="\n">
<endif>

<if(model.FPGAs)>
  /* initialize the FPGA driver */
  <model.FPGAs:{fpga|pilot_<fpga.Name>_init();};separator="\n">
<endif>

<if(model.AIO20s)>
  <model.AIO20s:{aio20|pilot_<aio20.Name>_init();};separator="\n">
<endif>

<if(model.IsTest)>
  /* initialize the test */
  pilot_test_init();
<endif>

  //init plc
  plc_init();

  printf("entering main loop.");

  /* entering main loop */
  pilot_main_loop();
}

////////////////////////////////////
// interrupt handler 

/* pilot_systick is called every millisecond */
void pilot_systick()
{
  /* increment tick counter */
  __tick++;
  __CURRENT_TIME.tv_nsec += 1000000L;
  if (__CURRENT_TIME.tv_nsec >= 1000000000L)
  {
    __CURRENT_TIME.tv_nsec = 0;
    __CURRENT_TIME.tv_sec++;
  }

  /* increment the timeout counter */
  pilot_comm_increment_cmd_timeout();
}

<if(model.IO16s)>
/* define io16 input changed irq callback */
void rpc_io16_input_changed(int slot)
{
  module_inputs_changed = slot;
}
<endif>

<if(model.Usarts)>
/* define usart receive callback handler */
<model.Usarts:{usart|<usart_callback(usart)>};separator="\n">
<endif>

/* gets called by the interrupt handler when a counter needs to be incremented */
void rpc_counter_increment(int counter)
{
  /* increment the counter */
  <model.counter8s:{counter8|
  pilot_<counter8.Name>_increment_counter(counter);
  };separator="\n">
}

void pilot_spi_transmit_done()
{
  pilot_comm_spi_tx_done();
}

//////////////////////////////////////

>>
